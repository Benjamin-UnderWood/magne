magne
=======

Curio, RabbitMQ, Distributed Task Queue

Python >= 3.6, curio >= 0.8, pika >= 0.11.2

使用
------

1.git clone或者download, 然后
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: 

    pip install -r requirements.txt
    cd magne/magne


2. 运行进程worker
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block::

    python run.py process --help

3. 运行coroutine消费者
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block::

    python run.py coroutine --help

模型
--------------

1. 进程worker
~~~~~~~~~~~~~~~~

比起celery, 更简单, celery的代码我是真不想看了~~~

分离publisher和consumer的配置, publisher一端可以随便用哪种库来发msg, 这需要保证exchange和msg的格式对就好了~不像celery,

consumer和publisher公用一套代码~~多麻烦


2. coroutine消费者
~~~~~~~~~~~~~~~~~~~~~


测试
-----------

测试环境: Ubuntu16.04 16G Intel(R) Core(TM) i5-4250U(4核)

测试参考: **dramatiq** https://github.com/Bogdanp/dramatiq/blob/master/benchmarks/bench.py

测试延迟函数: latency_bench(随机sleep(n), n不大于10)

下面绘制表格的库: https://github.com/allenling/draw-docs-table

1. 进程模式
~~~~~~~~~~~~

magne.process_worker

该模式就是孵化出n个子进程, 然后子进程只是执行任务而已

受限于进程数, 一般进程数不大于cpu个数, 所以限制了消费的速率, celery也是这个模式

+-------+--------------+----------+
|       +              +          +
| tasks + celery/magne + dramatiq +
|       +              +          +
+-------+--------------+----------+
|       +              +          +
| 100   + 45.12s       + 6.52s    +
|       +              +          +
+-------+--------------+----------+

2. 线程模式
~~~~~~~~~~~~~

3. coroutine消费者
~~~~~~~~~~~~~~~~~~~~~~~

**高低水位是必须的, 因为如果无限制的允许spawn的话, 可能会吃满cpu**

qos为0, 单进程的coroutine, dramatiq运行测试的时候默认是8个进程

+-------+-----------+----------+
|       +           +          +
| tasks + coroutine + dramatiq +
|       +           +          +
+-------+-----------+----------+
|       +           +          +
| 100   + 5.33s     + 6.52s    +
|       +           +          +
+-------+-----------+----------+
|       +           +          +
| 1000  + 10.46s    + 39.57s   +
|       +           +          +
+-------+-----------+----------+

当spawn太多任务, 达到1200+个的时候, 进程会吃满cpu, 然后挂起了

3.1 设置高低水位
++++++++++++++++++++++++++++++++++

当就绪任务(ready task)达到高水位的时候, 等待任务下降到低水位, 再继续spawn协程

低水位为400, 高水位为1000

+-------+-----------+----------+-----------------+
|       +           +          +                 +
| tasks + coroutine + dramatiq + dramatiq-gevent +
|       +           +          +                 +
+-------+-----------+----------+-----------------+
|       +           +          +                 +
| 1000  + 10.72s    + 39.57s   + 3.45s           +
|       +           +          +                 +
+-------+-----------+----------+-----------------+
|       +           +          +                 +
| 5000  + 28.95s    + 204.64s  + 15.69s          +
|       +           +          +                 +
+-------+-----------+----------+-----------------+
|       +           +          +                 +
| 10000 + 49.47s    + 408.10s  + 22.91s          +
|       +           +          +                 +
+-------+-----------+----------+-----------------+

3.2 多进程
++++++++++++

+-------+-------------+-------------+-------------+-------------+-------------+
|       +             +             +             +             +             +
| tasks + 2个进程     + 3个进程     + 4个进程     + 5个进程     + 6个进程     +
|       +             +             +             +             +             +
+-------+-------------+-------------+-------------+-------------+-------------+
|       +             +             +             +             +             +
| 1000  + 10.55s      + 10.67s      + 10.66s      + 差不多      + 差不多      +
|       +             +             +             +             +             +
+-------+-------------+-------------+-------------+-------------+-------------+
|       +             +             +             +             +             +
| 5000  + 19.00s      + 16.02s      + 16.10s      + 差不多      + 差不多      +
|       +             +             +             +             +             +
+-------+-------------+-------------+-------------+-------------+-------------+
|       +             +             +             +             +             +
| 10000 + 31.26s      + 25.94s      + 21.13s      + 19.03s      + 19.13s      +
|       +             +             +             +             +             +
+-------+-------------+-------------+-------------+-------------+-------------+

当进程数大于cpu个数的时候, 再多的进程也不会有提升了

3.3 wrap spawn
----------------------

上面高水位设置这么低是因为我们一直spawn, 但是没有启动coroutine, 所以导致太多的ready task, 而curio会有一些未定义行为

如果我们如果我们修改一下, spawn的时候确保coroutine能开始执行的话, 就绪任务就很少, 但是running任务就很多, 可以突破这个限制~~~

wrap spawn请看magne/coro_consumer

这种模式下, running任务数量都能达到3000-4000+个:

1. 测试数量达到1w个, 这时有4000+个running任务, cpu是基本吃满

2. 5000个amqp任务, running的任务最多3000+, cpu则30%-40%左右

**wrap spawn的方式请看magne/coro_consumer里面的readme**

+-------+------------+
|       +            +
| tasks + wrap spawn +
|       +            +
+-------+------------+
|       +            +
| 1000  + 差不多     +
|       +            +
+-------+------------+
|       +            +
| 5000  + 12.66s     +
|       +            +
+-------+------------+
|       +            +
| 10000 + 16.87s     +
|       +            +
+-------+------------+



小结
-------

0. 纯比速度其实意义不大了

1. 协程更有效率, 因为协程创建开销很低, 也就是一个协程对象, 然后用户态自己调度协程, 调度的开销也很低, 但是相应的, cpu会高挺多的, 这是因为用户代码频繁调度切换协程的关系,
   导致进程一直处于运行状态了

2. 现在python的异步io的"难点"在于工具不多:

   2.1 比如上面的coroutine消费者模式, 你的每一个task必须适应于curio, 比如sleep必须是curio.sleep等等, 否则consumer都不会yield, 这样就失去了协程的优势, 

   2.2 又比如如果写一个协程http服务器, 那么如果业务的view不能yield的话, 协程服务器并没有什么意义, 因为不yield的话就是卡在一个request上

       如果需要业务的view能够yield的话, 必须配套有比如reids, mysql这些异步工具,　然而现在并没有, 现在社区还是处于构建协程调度库(curio, asyncio, trio等等)状态


3. dramatiq的线程模型是真的快, 而且方便, 不需要有其他的定制(比如你的task必须适应curio), 是由os来调度~~加上gevent之后, 那是更快了

4. celery是多进程的模式, 受限于不能多开进程~~~并且最主要一点, 看代码找问题太麻烦了!!!!!

